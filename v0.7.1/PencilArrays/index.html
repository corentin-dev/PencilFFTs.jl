<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>MPI-distributed data · PencilFFTs.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../assets/tomate.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img alt="PencilFFTs.jl logo" src="../assets/logo.svg"/></a><div class="docs-package-name"><span class="docs-autofit">PencilFFTs.jl</span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">More examples</span><ul><li><a class="tocitem" href="../examples/in-place/">In-place transforms</a></li><li><a class="tocitem" href="../examples/gradient/">Gradient of a scalar field</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../PencilFFTs/">Distributed FFTs</a></li><li><a class="tocitem" href="../Transforms/">Available transforms</a></li><li class="is-active"><a class="tocitem" href="">MPI-distributed data</a><ul class="internal"><li><a class="tocitem" href="#sec:mpi_topology-1"><span>MPI topology</span></a></li><li><a class="tocitem" href="#sec:pencil_configs-1"><span>Pencil configurations</span></a></li><li><a class="tocitem" href="#Array-wrappers-1"><span>Array wrappers</span></a></li><li><a class="tocitem" href="#Global-MPI-operations-1"><span>Global MPI operations</span></a></li><li><a class="tocitem" href="#PencilArrays.measuring_performance-1"><span>Measuring performance</span></a></li><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../PencilIO/">Parallel I/O</a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="">MPI-distributed data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">MPI-distributed data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jipolanco/PencilFFTs.jl/blob/master/docs/src/PencilArrays.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="PencilArrays_module-1"><a class="docs-heading-anchor" href="#PencilArrays_module-1">MPI-distributed data</a><a class="docs-heading-anchor-permalink" href="#PencilArrays_module-1" title="Permalink"></a></h1><p>The distribution of global data among MPI processes is managed by the <a href="#PencilFFTs.PencilArrays"><code>PencilArrays</code></a> module. This module may be used independently of the FFT functionality.</p><p>The <a href="#PencilFFTs.PencilArrays"><code>PencilArrays</code></a> module defines types that describe <a href="#sec:mpi_topology-1">an MPI Cartesian topology</a> and <a href="#sec:pencil_configs-1">the decomposition of data over MPI processes</a>. The module also defines <a href="#Array-wrappers-1">array wrappers</a>, most notably the <a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilArray</code></a> type, which allow to conveniently and efficiently work with MPI-decomposed data.</p><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays" id="PencilFFTs.PencilArrays"><code>PencilFFTs.PencilArrays</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module for multidimensional data decomposition using MPI.</p><p>Handles different decomposition configurations and data transpositions between them. Also defines relevant data structures for handling distributed data.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/PencilArrays.jl#L1-L6" target="_blank">source</a></section></article><h2 id="sec:mpi_topology-1"><a class="docs-heading-anchor" href="#sec:mpi_topology-1">MPI topology</a><a class="docs-heading-anchor-permalink" href="#sec:mpi_topology-1" title="Permalink"></a></h2><p>The <a href="#PencilFFTs.PencilArrays.MPITopologies.MPITopology"><code>MPITopology</code></a> type defines the MPI Cartesian topology of the decomposition. In other words, it contains information about the number of decomposed dimensions, and the number of processes in each of these dimensions.</p><h3 id="Construction-1"><a class="docs-heading-anchor" href="#Construction-1">Construction</a><a class="docs-heading-anchor-permalink" href="#Construction-1" title="Permalink"></a></h3><p>The main <code>MPITopology</code> constructor takes a MPI communicator and a tuple specifying the number of processes in each dimension. For instance, to distribute 12 MPI processes on a <span>$3 × 4$</span> grid:</p><pre><code class="language-julia">comm = MPI.COMM_WORLD  # we assume MPI.Comm_size(comm) == 12
pdims = (3, 4)
topology = MPITopology(comm, pdims)</code></pre><p>At the lower level, <a href="#PencilFFTs.PencilArrays.MPITopologies.MPITopology"><code>MPITopology</code></a> uses <a href="https://www.mpich.org/static/docs/latest/www3/MPI_Cart_create.html"><code>MPI_Cart_create</code></a> to define a Cartesian MPI communicator. For more control, one can also create a Cartesian communicator using <code>MPI.Cart_create</code>, and pass that to <code>MPITopology</code>:</p><pre><code class="language-julia">comm = MPI.COMM_WORLD
dims = [3, 4]  # note: array, not tuple!
periods = zeros(Int, N)
reorder = false
comm_cart = MPI.Cart_create(comm, dims, periods, reorder)
topology = MPITopology(comm_cart)</code></pre><h3 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.MPITopologies.MPITopology" id="PencilFFTs.PencilArrays.MPITopologies.MPITopology"><code>PencilFFTs.PencilArrays.MPITopologies.MPITopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MPITopology{N}</code></pre><p>Describes an N-dimensional Cartesian MPI decomposition topology.</p><hr/><pre><code class="language-none">MPITopology(comm::MPI.Comm, pdims::Dims{N}) where N</code></pre><p>Create N-dimensional MPI topology information.</p><p>The <code>pdims</code> tuple specifies the number of MPI processes to put in every dimension of the topology. The product of its values must be equal to the number of processes in communicator <code>comm</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia"># Divide 2D topology into 4×2 blocks.
comm = MPI.COMM_WORLD
@assert MPI.Comm_size(comm) == 8
topology = MPITopology(comm, (4, 2))</code></pre><hr/><pre><code class="language-none">MPITopology{N}(comm_cart::MPI.Comm) where N</code></pre><p>Create topology information from MPI communicator with Cartesian topology (typically constructed using <code>MPI.Cart_create</code>). The topology must have dimension <code>N</code>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/MPITopologies.jl#L8-L40" target="_blank">source</a></section></article><h3 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.MPITopologies.get_comm-Tuple{MPITopology}" id="PencilFFTs.PencilArrays.MPITopologies.get_comm-Tuple{MPITopology}"><code>PencilFFTs.PencilArrays.MPITopologies.get_comm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_comm(t::MPITopology)</code></pre><p>Get MPI communicator associated to an MPI Cartesian topology.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/MPITopologies.jl#L128-L132" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.length-Tuple{MPITopology}" id="Base.length-Tuple{MPITopology}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(t::MPITopology)</code></pre><p>Get total size of Cartesian topology (i.e. total number of MPI processes).</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/MPITopologies.jl#L121-L125" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.ndims-Tuple{MPITopology}" id="Base.ndims-Tuple{MPITopology}"><code>Base.ndims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ndims(p::Pencil)</code></pre><p>Number of spatial dimensions associated to pencil data.</p><p>This corresponds to the total number of dimensions of the space, which includes the decomposed and non-decomposed dimensions.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L170-L177" target="_blank">source</a></section><section><div><pre><code class="language-none">ndims(t::MPITopology)</code></pre><p>Get dimensionality of Cartesian topology.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/MPITopologies.jl#L107-L111" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.size-Tuple{MPITopology}" id="Base.size-Tuple{MPITopology}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(t::MPITopology)</code></pre><p>Get dimensions of Cartesian topology.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/MPITopologies.jl#L114-L118" target="_blank">source</a></section></article><h2 id="sec:pencil_configs-1"><a class="docs-heading-anchor" href="#sec:pencil_configs-1">Pencil configurations</a><a class="docs-heading-anchor-permalink" href="#sec:pencil_configs-1" title="Permalink"></a></h2><p>A <em>pencil</em> configuration refers to a given distribution of multidimensional data among MPI processes. This information is encoded in the <a href="#PencilFFTs.PencilArrays.Pencil"><code>Pencil</code></a> type.</p><p>More precisely, a pencil configuration includes:</p><ul><li><a href="#sec:mpi_topology-1">MPI topology</a> information,</li><li>global and local dimensions of the numerical grid,</li><li>subset of decomposed dimensions,</li><li>type of decomposed data (e.g. <code>Float64</code>),</li><li>definition of optional permutation of dimensions.</li></ul><h3 id="Construction-2"><a class="docs-heading-anchor" href="#Construction-2">Construction</a><a class="docs-heading-anchor-permalink" href="#Construction-2" title="Permalink"></a></h3><p>The creation of a new <a href="#PencilFFTs.PencilArrays.Pencil"><code>Pencil</code></a> requires a <a href="#PencilFFTs.PencilArrays.MPITopologies.MPITopology"><code>MPITopology</code></a>, as well as the global data dimensions and a list of decomposed dimensions. Optionally, one can also specify the data type (the default is <code>Float64</code>) and a permutation of dimensions.</p><p>For instance, to decompose along the first and third dimensions of a complex 3D dataset,</p><pre><code class="language-julia">topology = MPITopology(#= ... =#)
dims_global = (16, 32, 64)
decomp_dims = (1, 3)  # this requires ndims(topology) == 2
pencil = Pencil(topology, dims_global, decomp_dims, Complex{Float64})</code></pre><p>One may also want to create multiple pencil configurations that differ, for instance, on the selection of decomposed dimensions. For this case, a second constructor is available that takes an already existing <code>Pencil</code> instance. Calling this constructor should be preferred when possible since it allows sharing memory buffers (used for instance for <a href="#Global-MPI-operations-1">global transpositions</a>) and thus reducing memory usage. The following creates a <code>Pencil</code> equivalent to the one above, but with different decomposed dimensions:</p><pre><code class="language-julia">pencil_x = Pencil(pencil, decomp_dims=(2, 3))</code></pre><p>See the <a href="#PencilFFTs.PencilArrays.Pencil"><code>Pencil</code></a> documentation for more details.</p><h3 id="Dimension-permutations-1"><a class="docs-heading-anchor" href="#Dimension-permutations-1">Dimension permutations</a><a class="docs-heading-anchor-permalink" href="#Dimension-permutations-1" title="Permalink"></a></h3><p>As mentioned above, a <code>Pencil</code> may optionally be given information on dimension permutations. In this case, the layout of the data arrays in memory is different from the logical order of dimensions.</p><p>To make this clearer, consider the example above where the global data dimensions are <span>$N_x × N_y × N_z = 16 × 32 × 64$</span>. In this case, the logical order is <span>$(x, y, z)$</span>. Now let's say that we want the memory order of the data to be <span>$(y, z, x)$</span>,<sup class="footnote-reference"><a href="#footnote-1" id="citeref-1">[1]</a></sup> which corresponds to the permutation <code>(2, 3, 1)</code>.</p><p>Permutations are passed to the <code>Pencil</code> constructor via the <code>permute</code> keyword argument. For performance reasons, dimension permutations are compile-time constants, and they should be specified using the <a href="#PencilFFTs.PencilArrays.Permutation"><code>Permutation</code></a> type defined in <code>PencilArrays</code>. For instance,</p><pre><code class="language-julia">permutation = Permutation(2, 3, 1)
pencil = Pencil(#= ... =#, permute=permutation)</code></pre><p>One can also pass <a href="#PencilFFTs.PencilArrays.NoPermutation"><code>NoPermutation</code></a> as a permutation, which disables permutations (this is the default).</p><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.Pencil" id="PencilFFTs.PencilArrays.Pencil"><code>PencilFFTs.PencilArrays.Pencil</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pencil{N,M,T}</code></pre><p>Describes the decomposition of an <code>N</code>-dimensional Cartesian geometry among MPI processes along <code>M</code> directions (with <code>M &lt; N</code>).</p><p>The <code>Pencil</code> describes the decomposition of arrays of element type <code>T</code>.</p><hr/><pre><code class="language-none">Pencil(topology::MPITopology{M}, size_global::Dims{N},
       decomp_dims::Dims{M}, [element_type=Float64];
       permute::Permutation=NoPermutation(),
       timer=TimerOutput())</code></pre><p>Define the decomposition of an <code>N</code>-dimensional geometry along <code>M</code> dimensions.</p><p>The dimensions of the geometry are given by <code>size_global = (N1, N2, ...)</code>. The <code>Pencil</code> describes the decomposition of an array of dimensions <code>size_global</code> and type <code>T</code> across a group of MPI processes.</p><p>Data is distributed over the given <code>M</code>-dimensional MPI topology (with <code>M &lt; N</code>). The decomposed dimensions are given by <code>decomp_dims</code>.</p><p>The optional parameter <code>perm</code> should be a (compile-time) tuple defining a permutation of the data indices. Such permutation may be useful for performance reasons, since it may be preferable (e.g. for FFTs) that the data is contiguous along the pencil direction.</p><p>It is also possible to pass a <code>TimerOutput</code> to the constructor. See <a href="#PencilArrays.measuring_performance-1">Measuring performance</a> for details.</p><p><strong>Examples</strong></p><p>Decompose a 3D geometry of global dimensions <span>$N_x × N_y × N_z = 4×8×12$</span> along the second (<span>$y$</span>) and third (<span>$z$</span>) dimensions.</p><pre><code class="language-julia">Pencil(topology, (4, 8, 12), (2, 3))                          # data is in (x, y, z) order
Pencil(topology, (4, 8, 12), (2, 3), permute=Permutation(3, 2, 1))  # data is in (z, y, x) order</code></pre><p>In the second case, the actual data is stored in <code>(z, y, x)</code> order within each MPI process.</p><hr/><pre><code class="language-none">Pencil(p::Pencil{N,M}, [element_type=eltype(p)];
       decomp_dims::Dims{M}=get_decomposition(p),
       size_global::Dims{N}=size_global(p),
       permute::P=get_permutation(p),
       timer::TimerOutput=get_timer(p))</code></pre><p>Create new pencil configuration from an existent one.</p><p>This constructor enables sharing temporary data buffers between the two pencil configurations, leading to reduced global memory usage.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L1-L56" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.Permutation" id="PencilFFTs.PencilArrays.Permutation"><code>PencilFFTs.PencilArrays.Permutation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Permutation{p}</code></pre><p>Describes a compile-time dimension permutation.</p><p>The type parameter <code>p</code> should be a valid permutation such as <code>(3, 1, 2)</code>.</p><p>The parameter <code>p</code> may also be <code>nothing</code>. A <code>Permutation{nothing}</code> represents an identity permutation: it is equivalent to <code>Permutation{(1, 2, …, N)}</code> for any number of dimensions <code>N</code>. The <a href="#PencilFFTs.PencilArrays.NoPermutation"><code>NoPermutation</code></a> type is provided as an alias for <code>Permutation{nothing}</code>.</p><hr/><pre><code class="language-none">Permutation(perm::Vararg{Int})
Permutation(perm::NTuple{N,Int})</code></pre><p>Constructs a <code>Permutation</code>.</p><p><strong>Example</strong></p><p>Both are equivalent:</p><pre><code class="language-julia">p1 = Permutation(3, 4)
p2 = Permutation((3, 4))</code></pre><hr/><pre><code class="language-none">Permutation(nothing)
NoPermutation()</code></pre><p>Constructs an identity permutation.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/types.jl#L1-L36" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.NoPermutation" id="PencilFFTs.PencilArrays.NoPermutation"><code>PencilFFTs.PencilArrays.NoPermutation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoPermutation</code></pre><p>Alias for an identity permutation, i.e. <code>NoPermutation = Permutation{nothing}</code>.</p><p>This alias can be called as a constructor: <code>NoPermutation()</code> creates a <code>Permutation{nothing}</code>, as expected.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/types.jl#L45-L52" target="_blank">source</a></section></article><h3 id="Methods-2"><a class="docs-heading-anchor" href="#Methods-2">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Base.eltype-Tuple{Pencil}" id="Base.eltype-Tuple{Pencil}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eltype(Pencil)
eltype(p::Pencil)</code></pre><p>Element type associated to the given pencil type.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L153-L158" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.MPITopologies.get_comm-Tuple{Pencil}" id="PencilFFTs.PencilArrays.MPITopologies.get_comm-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.MPITopologies.get_comm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_comm(p::Pencil)</code></pre><p>Get MPI communicator associated to an MPI decomposition scheme.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L180-L184" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.get_decomposition-Tuple{Pencil}" id="PencilFFTs.PencilArrays.get_decomposition-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.get_decomposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_decomposition(p::Pencil)</code></pre><p>Get tuple with decomposed dimensions of the given pencil configuration.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L196-L200" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.get_permutation-Tuple{Pencil}" id="PencilFFTs.PencilArrays.get_permutation-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.get_permutation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_permutation(p::Pencil)</code></pre><p>Get index permutation associated to the given pencil configuration.</p><p>Returns <code>NoPermutation()</code> if there is no associated permutation.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L187-L193" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.length-Tuple{Pencil}" id="Base.length-Tuple{Pencil}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(p::Pencil)</code></pre><p>Get linear length of data associated to the local pencil layout.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L203-L207" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.ndims-Tuple{Pencil}" id="Base.ndims-Tuple{Pencil}"><code>Base.ndims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ndims(p::Pencil)</code></pre><p>Number of spatial dimensions associated to pencil data.</p><p>This corresponds to the total number of dimensions of the space, which includes the decomposed and non-decomposed dimensions.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L170-L177" target="_blank">source</a></section><section><div><pre><code class="language-none">ndims(t::MPITopology)</code></pre><p>Get dimensionality of Cartesian topology.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/MPITopologies.jl#L107-L111" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.range_local-Union{Tuple{Pencil{N,M,T,P} where P where T&lt;:Number where M}, Tuple{N}} where N" id="PencilFFTs.PencilArrays.range_local-Union{Tuple{Pencil{N,M,T,P} where P where T&lt;:Number where M}, Tuple{N}} where N"><code>PencilFFTs.PencilArrays.range_local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">range_local(p::Pencil; permute=false)</code></pre><p>Local data range held by the pencil.</p><p>By default the dimensions are not permuted, i.e. they follow the logical order of dimensions.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L210-L217" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.size_global-Tuple{Pencil}" id="PencilFFTs.PencilArrays.size_global-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.size_global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size_global(p::Pencil; permute=false)</code></pre><p>Global dimensions of the Cartesian grid associated to the given domain decomposition.</p><p>Like <a href="#PencilFFTs.PencilArrays.size_local-Tuple{Pencil}"><code>size_local</code></a>, by default the returned dimensions are not permuted.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L232-L239" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.size_local-Tuple{Pencil}" id="PencilFFTs.PencilArrays.size_local-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.size_local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size_local(p::Pencil; permute=false)</code></pre><p>Local dimensions of the data held by the pencil.</p><p>By default the dimensions are not permuted, i.e. they follow the logical order of dimensions.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L221-L228" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.to_local-Tuple{Pencil}" id="PencilFFTs.PencilArrays.to_local-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.to_local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_local(p::Pencil, global_inds; permute=false)</code></pre><p>Convert non-permuted global indices to local indices.</p><p>Indices can be optionally permuted using the permutation associated to the pencil configuration <code>p</code>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/pencil.jl#L243-L250" target="_blank">source</a></section></article><h2 id="Array-wrappers-1"><a class="docs-heading-anchor" href="#Array-wrappers-1">Array wrappers</a><a class="docs-heading-anchor-permalink" href="#Array-wrappers-1" title="Permalink"></a></h2><p>The <code>PencilArrays</code> module also defines a <a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilArray</code></a> type that wraps an <code>AbstractArray</code> while including pencil decomposition information.</p><h3 id="Construction-3"><a class="docs-heading-anchor" href="#Construction-3">Construction</a><a class="docs-heading-anchor-permalink" href="#Construction-3" title="Permalink"></a></h3><p>A <code>PencilArray</code> wrapper can be simply constructed from a <code>Pencil</code> instance as</p><pre><code class="language-julia">pencil = Pencil(#= ... =#)
A = PencilArray(pencil)
parent(A)  # returns the allocated Array</code></pre><p>This allocates a new <code>Array</code> with the local dimensions and data type associated to the <code>Pencil</code>.</p><p>One can also construct a <code>PencilArray</code> wrapper from an existing <code>AbstractArray</code>, whose dimensions and type must be compatible with the <code>Pencil</code> configuration. For instance, the following works:</p><pre><code class="language-julia">T = eltype(pencil)
dims = size_local(pencil, permute=true)  # dimensions of data array must be permuted!
data = Array{T}(undef, dims)
A = PencilArray(pencil, data)</code></pre><p>Note that <code>data</code> does not need to be a <code>Array</code>, but can be any subtype of <code>AbstractArray</code>.</p><h3 id="Dimension-permutations-2"><a class="docs-heading-anchor" href="#Dimension-permutations-2">Dimension permutations</a><a class="docs-heading-anchor-permalink" href="#Dimension-permutations-2" title="Permalink"></a></h3><p>Unlike the wrapped <code>AbstractArray</code>, the <code>PencilArray</code> wrapper takes non-permuted indices. For instance, if the underlying permutation of the <code>Pencil</code> is <code>(2, 3, 1)</code>, then <code>A[i, j, k]</code> points to the same value as <code>parent(A)[j, k, i]</code>.</p><h3 id="Global-views-1"><a class="docs-heading-anchor" href="#Global-views-1">Global views</a><a class="docs-heading-anchor-permalink" href="#Global-views-1" title="Permalink"></a></h3><p><code>PencilArray</code>s are accessed using local indices that start at 1, regardless of the location of the subdomain associated to the local process on the global grid. Sometimes it may be more convenient to use global indices describing the position of the local process in the domain. For this, the <a href="#PencilFFTs.PencilArrays.global_view-Tuple{PencilArray}"><code>global_view</code></a> function is provided that generates an <a href="https://github.com/JuliaArrays/OffsetArrays.jl"><code>OffsetArray</code></a> wrapper taking global indices. For more details, see for instance <a href="../examples/gradient/#gradient_method_global-1">the gradient example</a>.</p><h3 id="Types-3"><a class="docs-heading-anchor" href="#Types-3">Types</a><a class="docs-heading-anchor-permalink" href="#Types-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.PencilArray" id="PencilFFTs.PencilArrays.PencilArray"><code>PencilFFTs.PencilArrays.PencilArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PencilArray(pencil::Pencil, data::AbstractArray{T,N})</code></pre><p>Create array wrapper with pencil decomposition information.</p><p>The array dimensions and element type must be consistent with those of the given pencil.</p><div class="admonition is-info"><header class="admonition-header">Index permutations</header><div class="admonition-body"><p>If the <code>Pencil</code> has an associated index permutation, then <code>data</code> must have its dimensions permuted accordingly.</p><p>Unlike <code>data</code>, the resulting <code>PencilArray</code> should be accessed with unpermuted indices.</p><h5>Example</h5><p>Suppose <code>pencil</code> has local dimensions <code>(10, 20, 30)</code> before permutation, and has an asociated permutation <code>(2, 3, 1)</code>. Then:</p><pre><code class="language-julia">data = zeros(20, 30, 10)       # parent array (with permuted dimensions)

u = PencilArray(pencil, data)  # wrapper with dimensions (10, 20, 30)
@assert size(u) === (10, 20, 30)

u[15, 25, 5]          # BoundsError (15 &gt; 10 and 25 &gt; 20)
u[5, 15, 25]          # correct
parent(u)[15, 25, 5]  # correct
</code></pre></div></div><div class="admonition is-info"><header class="admonition-header">Extra dimensions</header><div class="admonition-body"><p>The data array can have one or more extra dimensions to the right (slow indices), which are not affected by index permutations.</p><h5>Example</h5><pre><code class="language-julia">dims = (20, 30, 10)
PencilArray(pencil, zeros(dims...))        # works (scalar)
PencilArray(pencil, zeros(dims..., 3))     # works (3-component vector)
PencilArray(pencil, zeros(dims..., 4, 3))  # works (4×3 tensor)
PencilArray(pencil, zeros(3, dims...))     # fails</code></pre></div></div><hr/><pre><code class="language-none">PencilArray(pencil::Pencil, [extra_dims=()])</code></pre><p>Allocate an uninitialised <code>PencilArray</code> that can hold data in the local pencil.</p><p>Extra dimensions, for instance representing vector components, can be specified. These dimensions are added to the rightmost (slowest) indices of the resulting array.</p><p><strong>Example</strong></p><p>Suppose <code>pencil</code> has local dimensions <code>(20, 10, 30)</code> after permutation. Then:</p><pre><code class="language-julia">PencilArray(pencil)          # array dimensions are (20, 10, 30)
PencilArray(pencil, (4, 3))  # array dimensions are (20, 10, 30, 4, 3)</code></pre></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L1-L65" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.PencilArrayCollection" id="PencilFFTs.PencilArrays.PencilArrayCollection"><code>PencilFFTs.PencilArrays.PencilArrayCollection</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">PencilArrayCollection</code></pre><p><code>UnionAll</code> type describing a collection of <a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilArray</code></a>s.</p><p>Such a collection can be a tuple or an array of <code>PencilArray</code>s.</p><p>Collections are <strong>by assumption</strong> homogeneous: each array has the same properties, and in particular, is associated to the same <a href="#PencilFFTs.PencilArrays.Pencil"><code>Pencil</code></a> configuration.</p><p>For convenience, certain operations defined for <code>PencilArray</code> are also defined for <code>PencilArrayCollection</code>, and return the same value as for a single <code>PencilArray</code>. Some examples are <a href="#PencilFFTs.PencilArrays.pencil-Tuple{PencilArray}"><code>pencil</code></a>, <a href="#PencilFFTs.PencilArrays.range_local-Union{Tuple{Pencil{N,M,T,P} where P where T&lt;:Number where M}, Tuple{N}} where N"><code>range_local</code></a> and <a href="#PencilFFTs.PencilArrays.MPITopologies.get_comm-Tuple{MPITopology}"><code>get_comm</code></a>.</p><p>Also note that functions from <code>Base</code>, such as <code>size</code> or <code>ndims</code>, are <strong>not</strong> overloaded for <code>PencilArrayCollection</code>, since they already have a definition for tuples and arrays (and redefining them would be type piracy...).</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L109-L129" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.MaybePencilArrayCollection" id="PencilFFTs.PencilArrays.MaybePencilArrayCollection"><code>PencilFFTs.PencilArrays.MaybePencilArrayCollection</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">MaybePencilArrayCollection</code></pre><p><code>UnionAll</code> type representing either a <a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilArray</code></a> or a collection of <a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilArray</code></a>s.</p><p>See also <a href="#PencilFFTs.PencilArrays.PencilArrayCollection"><code>PencilArrayCollection</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L136-L143" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.ManyPencilArray" id="PencilFFTs.PencilArrays.ManyPencilArray"><code>PencilFFTs.PencilArrays.ManyPencilArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ManyPencilArray{T,N,M}</code></pre><p>Container holding <code>M</code> different <a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilArray</code></a> views to the same underlying data buffer. All views share the same element type <code>T</code> and dimensionality <code>N</code>.</p><p>This can be useful to perform in-place operations on <code>PencilArray</code> data.</p><hr/><pre><code class="language-none">ManyPencilArray(pencils...; extra_dims=())</code></pre><p>Create a <code>ManyPencilArray</code> container that can hold data associated to all the given <a href="#PencilFFTs.PencilArrays.Pencil"><code>Pencil</code></a>s.</p><p>The optional <code>extra_dims</code> argument is the same as for <a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilArray</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/multiarrays.jl#L1-L18" target="_blank">source</a></section></article><h3 id="PencilArray-methods-1"><a class="docs-heading-anchor" href="#PencilArray-methods-1">PencilArray methods</a><a class="docs-heading-anchor-permalink" href="#PencilArray-methods-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.extra_dims-Tuple{PencilArray}" id="PencilFFTs.PencilArrays.extra_dims-Tuple{PencilArray}"><code>PencilFFTs.PencilArrays.extra_dims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extra_dims(x::PencilArray)
extra_dims(x::PencilArrayCollection)</code></pre><p>Return tuple with size of "extra" dimensions of <code>PencilArray</code>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L292-L297" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.MPITopologies.get_comm-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}" id="PencilFFTs.PencilArrays.MPITopologies.get_comm-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.MPITopologies.get_comm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_comm(x::PencilArray)
get_comm(x::PencilArrayCollection)</code></pre><p>Get MPI communicator associated to a pencil-distributed array.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L326-L331" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.get_permutation-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}" id="PencilFFTs.PencilArrays.get_permutation-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.get_permutation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_permutation(x::PencilArray)
get_permutation(x::PencilArrayCollection)</code></pre><p>Get index permutation associated to the given <code>PencilArray</code>.</p><p>Returns <code>NoPermutation()</code> if there is no associated permutation.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L334-L341" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.global_view-Tuple{PencilArray}" id="PencilFFTs.PencilArrays.global_view-Tuple{PencilArray}"><code>PencilFFTs.PencilArrays.global_view</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">global_view(x::PencilArray)</code></pre><p>Create an <a href="https://github.com/JuliaArrays/OffsetArrays.jl"><code>OffsetArray</code></a> of a <code>PencilArray</code> that takes unpermuted global indices.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/global_view.jl#L3-L8" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.ndims_extra-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}" id="PencilFFTs.PencilArrays.ndims_extra-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.ndims_extra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ndims_extra(x::PencilArray)
ndims_extra(x::PencilArrayCollection)</code></pre><p>Number of "extra" dimensions associated to <code>PencilArray</code>.</p><p>These are the dimensions that are not associated to the domain geometry. For instance, they may correspond to vector or tensor components.</p><p>These dimensions correspond to the rightmost indices of the array.</p><p>The total number of dimensions of a <code>PencilArray</code> is given by:</p><pre><code class="language-none">ndims(x) == ndims_space(x) + ndims_extra(x)</code></pre></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L258-L273" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.ndims_space-Tuple{PencilArray}" id="PencilFFTs.PencilArrays.ndims_space-Tuple{PencilArray}"><code>PencilFFTs.PencilArrays.ndims_space</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ndims_space(x::PencilArray)
ndims_space(x::PencilArrayCollection)</code></pre><p>Number of dimensions associated to the domain geometry.</p><p>These dimensions correspond to the leftmost indices of the array.</p><p>The total number of dimensions of a <code>PencilArray</code> is given by:</p><pre><code class="language-none">ndims(x) == ndims_space(x) + ndims_extra(x)</code></pre></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L276-L288" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.parent-Tuple{PencilArray}" id="Base.parent-Tuple{PencilArray}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parent(x::PencilArray)</code></pre><p>Return array wrapped by a <code>PencilArray</code>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L237-L241" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.pencil-Tuple{PencilArray}" id="PencilFFTs.PencilArrays.pencil-Tuple{PencilArray}"><code>PencilFFTs.PencilArrays.pencil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pencil(x::PencilArray)</code></pre><p>Return decomposition configuration associated to a <code>PencilArray</code>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L229-L233" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.pointer-Tuple{PencilArray}" id="Base.pointer-Tuple{PencilArray}"><code>Base.pointer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pointer(x::PencilArray)</code></pre><p>Return pointer to the start of the underlying data.</p><p>Use with caution: this may not make a lot of sense if the underlying data is not contiguous or strided (e.g. if the <code>PencilArray</code> is wrapping a non-strided <code>SubArray</code>).</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L247-L255" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.range_local-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}" id="PencilFFTs.PencilArrays.range_local-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.range_local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">range_local(x::PencilArray; permute=false)
range_local(x::PencilArrayCollection; permute=false)</code></pre><p>Local data range held by the <code>PencilArray</code>.</p><p>By default the dimensions are not permuted, i.e. they are returned in logical order.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L314-L322" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.size-Tuple{PencilArray}" id="Base.size-Tuple{PencilArray}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(x::PencilArray)</code></pre><p>Return logical (unpermuted) local dimensions of a <code>PencilArray</code>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L154-L158" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.size_local-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}" id="PencilFFTs.PencilArrays.size_local-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.size_local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size_local(x::PencilArray; permute=false)
size_local(x::PencilArrayCollection; permute=false)</code></pre><p>Local dimensions of the data held by the <code>PencilArray</code>.</p><p>If <code>permute=false</code>, this is the same as <code>size(x)</code>.</p><p>See also <a href="#PencilFFTs.PencilArrays.size_local-Tuple{Pencil}"><code>size_local(::Pencil)</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L161-L170" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.size_global-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}" id="PencilFFTs.PencilArrays.size_global-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.size_global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size_global(x::PencilArray; permute=false)
size_global(x::PencilArrayCollection; permute=false)</code></pre><p>Global dimensions associated to the given array.</p><p>By default, the logical (unpermuted) dimensions of the dataset are returned.</p><p>See also <a href="#PencilFFTs.PencilArrays.size_global-Tuple{Pencil}"><code>size_global(::Pencil)</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L301-L310" target="_blank">source</a></section></article><h3 id="ManyPencilArray-methods-1"><a class="docs-heading-anchor" href="#ManyPencilArray-methods-1">ManyPencilArray methods</a><a class="docs-heading-anchor-permalink" href="#ManyPencilArray-methods-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Base.first-Tuple{ManyPencilArray}" id="Base.first-Tuple{ManyPencilArray}"><code>Base.first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">first(A::ManyPencilArray)</code></pre><p>Returns the first <a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilArray</code></a> wrapped by <code>A</code>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/multiarrays.jl#L64-L68" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.getindex-Tuple{ManyPencilArray}" id="Base.getindex-Tuple{ManyPencilArray}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(A::ManyPencilArray, ::Val{i})
getindex(A::ManyPencilArray, i::Integer)</code></pre><p>Returns the i-th <a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilArray</code></a> wrapped by <code>A</code>.</p><p>If possible, the <code>Val{i}</code> form should be preferred, as it is more efficient and it allows the compiler to know the return type.</p><p>See also <a href="#Base.first-Tuple{ManyPencilArray}"><code>first(::ManyPencilArray)</code></a>, <a href="#Base.last-Tuple{ManyPencilArray}"><code>last(::ManyPencilArray)</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">A = ManyPencilArray(pencil1, pencil2, pencil3)

# Get the PencilArray associated to `pencil2`.
# u2 = A[2]
u2 = A[Val(2)]  # faster!</code></pre></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/multiarrays.jl#L78-L98" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.last-Tuple{ManyPencilArray}" id="Base.last-Tuple{ManyPencilArray}"><code>Base.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">last(A::ManyPencilArray)</code></pre><p>Returns the last <a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilArray</code></a> wrapped by <code>A</code>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/multiarrays.jl#L71-L75" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.length-Tuple{ManyPencilArray}" id="Base.length-Tuple{ManyPencilArray}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(A::ManyPencilArray)</code></pre><p>Returns the number of <a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilArray</code></a>s wrapped by <code>A</code>.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/multiarrays.jl#L57-L61" target="_blank">source</a></section></article><h2 id="Global-MPI-operations-1"><a class="docs-heading-anchor" href="#Global-MPI-operations-1">Global MPI operations</a><a class="docs-heading-anchor-permalink" href="#Global-MPI-operations-1" title="Permalink"></a></h2><p>One of the most time-consuming parts of a large-scale computation involving multidimensional FFTs, is the global data transpositions between different MPI decomposition configurations. In <code>PencilArrays</code>, this is performed by the <a href="#LinearAlgebra.transpose!"><code>transpose!</code></a> function, which takes two <code>PencilArray</code>s, typically associated to two different configurations. The implementation performs comparably to similar implementations in lower-level languages (see <a href="../benchmarks/#Benchmarks-1">Benchmarks</a>).</p><p>Also provided is a <a href="#PencilFFTs.PencilArrays.gather"><code>gather</code></a> function that creates a single global array from decomposed data. This can be useful for tests (in fact, it is used in the <code>PencilArrays</code> tests to verify the correctness of the transpositions), but shouldn't be used with large datasets. It is generally useful for small problems where the global size of the data can easily fit the locally available memory.</p><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.Transpositions.Transposition" id="PencilFFTs.PencilArrays.Transpositions.Transposition"><code>PencilFFTs.PencilArrays.Transpositions.Transposition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Transposition</code></pre><p>Holds data for transposition between two pencil configurations.</p><hr/><pre><code class="language-none">Transposition(dest::PencilArray{T,N}, src::PencilArray{T,N};
              method=Transpositions.IsendIrecv())</code></pre><p>Prepare transposition of arrays from one pencil configuration to the other.</p><p>The two pencil configurations must be compatible for transposition:</p><ul><li><p>they must share the same MPI Cartesian topology,</p></li><li><p>they must have the same global data size,</p></li><li><p>when written as a sorted tuple, the decomposed dimensions must be almost the same, with at most one difference. For instance, if the input of a 3D dataset is decomposed in <code>(2, 3)</code>, then the output may be decomposed in <code>(1, 3)</code>, but not in <code>(1, 2)</code>. If the decomposed dimensions are the same, then no transposition is performed, and data is just copied if needed.</p></li></ul><p>The <code>src</code> and <code>dest</code> arrays may be aliased (they can share memory space).</p><p><strong>Performance tuning</strong></p><p>The <code>method</code> argument allows to choose between transposition implementations. This can be useful to tune performance of MPI data transfers. Two values are currently accepted:</p><ul><li><p><code>Transpositions.IsendIrecv()</code> uses non-blocking point-to-point data transfers (<code>MPI_Isend</code> and <code>MPI_Irecv</code>). This may be more performant since data transfers are interleaved with local data transpositions (index permutation of received data). This is the default.</p></li><li><p><code>Transpositions.Alltoallv()</code> uses <code>MPI_Alltoallv</code> for global data transpositions.</p></li></ul></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/Transpositions.jl#L27-L67" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#LinearAlgebra.transpose!" id="LinearAlgebra.transpose!"><code>LinearAlgebra.transpose!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transpose!(t::Transposition; waitall=true)
transpose!(dest::PencilArray{T,N}, src::PencilArray{T,N};
           method=Transpositions.IsendIrecv())</code></pre><p>Transpose data from one pencil configuration to the other.</p><p>The first variant allows to optionally delay the wait for MPI send operations to complete. This is useful if the caller wants to perform other operations with the already received data. To do this, the caller should pass <code>waitall=false</code>, and manually invoke <a href="#MPI.Waitall!"><code>MPI.Waitall!</code></a> on the <code>Transposition</code> object once the operations are done. Note that this option only has an effect when the transposition method is <code>IsendIrecv</code>.</p><p>See <a href="#PencilFFTs.PencilArrays.Transpositions.Transposition"><code>Transposition</code></a> for details.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/Transpositions.jl#L118-L135" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#MPI.Waitall!" id="MPI.Waitall!"><code>MPI.Waitall!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">MPI.Waitall!(t::Transposition)</code></pre><p>Wait for completion of all unfinished MPI communications related to the transposition.</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/Transpositions.jl#L109-L114" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#PencilFFTs.PencilArrays.gather" id="PencilFFTs.PencilArrays.gather"><code>PencilFFTs.PencilArrays.gather</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gather(x::PencilArray, [root::Integer=0])</code></pre><p>Gather data from all MPI processes into one (big) array.</p><p>Data is received by the <code>root</code> process.</p><p>Returns the full array on the <code>root</code> process, and <code>nothing</code> on the other processes.</p><p>This can be useful for testing, but it shouldn't be used with very large datasets!</p></div><a class="docs-sourcelink" href="https://github.com/jipolanco/PencilFFTs.jl/blob/98629836a0841f8bc4684ab42096c3d6d3068536/src/PencilArrays/arrays.jl#L350-L362" target="_blank">source</a></section></article><h2 id="PencilArrays.measuring_performance-1"><a class="docs-heading-anchor" href="#PencilArrays.measuring_performance-1">Measuring performance</a><a class="docs-heading-anchor-permalink" href="#PencilArrays.measuring_performance-1" title="Permalink"></a></h2><p>It is possible to measure the time spent in different sections of the MPI data transposition routines using the <a href="https://github.com/KristofferC/TimerOutputs.jl">TimerOutputs</a> package. This has a (very small) performance overhead, so it is disabled by default. To enable time measurements, call <code>TimerOutputs.enable_debug_timings</code> after loading <code>PencilFFTs</code> (see below for an example). For more details see the <a href="https://github.com/KristofferC/TimerOutputs.jl#overhead">TimerOutputs docs</a>.</p><p>Minimal example:</p><pre><code class="language-julia">using MPI
using PencilFFTs.PencilArrays
using TimerOutputs

# Enable timing of `PencilArrays` functions
TimerOutputs.enable_debug_timings(PencilArrays)
TimerOutputs.enable_debug_timings(Transpositions)

MPI.Init()

pencil = Pencil(#= args... =#)

# [do stuff with `pencil`...]

# Retrieve and print timing data associated to `plan`
to = get_timer(pencil)
print_timer(to)</code></pre><p>By default, each <code>Pencil</code> has its own <code>TimerOutput</code>. If you already have a <code>TimerOutput</code>, you can pass it to the <a href="#PencilFFTs.PencilArrays.Pencil"><code>Pencil</code></a> constructor:</p><pre><code class="language-julia">to = TimerOutput()
pencil = Pencil(..., timer=to)

# [do stuff with `pencil`...]

print_timer(to)</code></pre><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#PencilFFTs.PencilArrays"><code>PencilFFTs.PencilArrays</code></a></li><li><a href="#PencilFFTs.PencilArrays.MPITopologies.MPITopology"><code>PencilFFTs.PencilArrays.MPITopologies.MPITopology</code></a></li><li><a href="#PencilFFTs.PencilArrays.ManyPencilArray"><code>PencilFFTs.PencilArrays.ManyPencilArray</code></a></li><li><a href="#PencilFFTs.PencilArrays.NoPermutation"><code>PencilFFTs.PencilArrays.NoPermutation</code></a></li><li><a href="#PencilFFTs.PencilArrays.Pencil"><code>PencilFFTs.PencilArrays.Pencil</code></a></li><li><a href="#PencilFFTs.PencilArrays.PencilArray"><code>PencilFFTs.PencilArrays.PencilArray</code></a></li><li><a href="#PencilFFTs.PencilArrays.Permutation"><code>PencilFFTs.PencilArrays.Permutation</code></a></li><li><a href="#PencilFFTs.PencilArrays.Transpositions.Transposition"><code>PencilFFTs.PencilArrays.Transpositions.Transposition</code></a></li><li><a href="#PencilFFTs.PencilArrays.MaybePencilArrayCollection"><code>PencilFFTs.PencilArrays.MaybePencilArrayCollection</code></a></li><li><a href="#PencilFFTs.PencilArrays.PencilArrayCollection"><code>PencilFFTs.PencilArrays.PencilArrayCollection</code></a></li><li><a href="#Base.eltype-Tuple{Pencil}"><code>Base.eltype</code></a></li><li><a href="#Base.first-Tuple{ManyPencilArray}"><code>Base.first</code></a></li><li><a href="#Base.getindex-Tuple{ManyPencilArray}"><code>Base.getindex</code></a></li><li><a href="#Base.last-Tuple{ManyPencilArray}"><code>Base.last</code></a></li><li><a href="#Base.length-Tuple{ManyPencilArray}"><code>Base.length</code></a></li><li><a href="#Base.length-Tuple{MPITopology}"><code>Base.length</code></a></li><li><a href="#Base.length-Tuple{Pencil}"><code>Base.length</code></a></li><li><a href="#Base.ndims-Tuple{Pencil}"><code>Base.ndims</code></a></li><li><a href="#Base.ndims-Tuple{MPITopology}"><code>Base.ndims</code></a></li><li><a href="#Base.parent-Tuple{PencilArray}"><code>Base.parent</code></a></li><li><a href="#Base.pointer-Tuple{PencilArray}"><code>Base.pointer</code></a></li><li><a href="#Base.size-Tuple{PencilArray}"><code>Base.size</code></a></li><li><a href="#Base.size-Tuple{MPITopology}"><code>Base.size</code></a></li><li><a href="#LinearAlgebra.transpose!"><code>LinearAlgebra.transpose!</code></a></li><li><a href="#MPI.Waitall!"><code>MPI.Waitall!</code></a></li><li><a href="#PencilFFTs.PencilArrays.MPITopologies.get_comm-Tuple{MPITopology}"><code>PencilFFTs.PencilArrays.MPITopologies.get_comm</code></a></li><li><a href="#PencilFFTs.PencilArrays.MPITopologies.get_comm-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.MPITopologies.get_comm</code></a></li><li><a href="#PencilFFTs.PencilArrays.MPITopologies.get_comm-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.MPITopologies.get_comm</code></a></li><li><a href="#PencilFFTs.PencilArrays.extra_dims-Tuple{PencilArray}"><code>PencilFFTs.PencilArrays.extra_dims</code></a></li><li><a href="#PencilFFTs.PencilArrays.gather"><code>PencilFFTs.PencilArrays.gather</code></a></li><li><a href="#PencilFFTs.PencilArrays.get_decomposition-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.get_decomposition</code></a></li><li><a href="#PencilFFTs.PencilArrays.get_permutation-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.get_permutation</code></a></li><li><a href="#PencilFFTs.PencilArrays.get_permutation-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.get_permutation</code></a></li><li><a href="#PencilFFTs.PencilArrays.global_view-Tuple{PencilArray}"><code>PencilFFTs.PencilArrays.global_view</code></a></li><li><a href="#PencilFFTs.PencilArrays.ndims_extra-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.ndims_extra</code></a></li><li><a href="#PencilFFTs.PencilArrays.ndims_space-Tuple{PencilArray}"><code>PencilFFTs.PencilArrays.ndims_space</code></a></li><li><a href="#PencilFFTs.PencilArrays.pencil-Tuple{PencilArray}"><code>PencilFFTs.PencilArrays.pencil</code></a></li><li><a href="#PencilFFTs.PencilArrays.range_local-Union{Tuple{Pencil{N,M,T,P} where P where T&lt;:Number where M}, Tuple{N}} where N"><code>PencilFFTs.PencilArrays.range_local</code></a></li><li><a href="#PencilFFTs.PencilArrays.range_local-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.range_local</code></a></li><li><a href="#PencilFFTs.PencilArrays.size_global-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.size_global</code></a></li><li><a href="#PencilFFTs.PencilArrays.size_global-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.size_global</code></a></li><li><a href="#PencilFFTs.PencilArrays.size_local-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A&lt;:PencilArray}}"><code>PencilFFTs.PencilArrays.size_local</code></a></li><li><a href="#PencilFFTs.PencilArrays.size_local-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.size_local</code></a></li><li><a href="#PencilFFTs.PencilArrays.to_local-Tuple{Pencil}"><code>PencilFFTs.PencilArrays.to_local</code></a></li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Why would we want this? Perhaps because we want to efficiently perform FFTs along <span>$y$</span>, which, under this permutation, would be the fastest dimension.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Transforms/">« Available transforms</a><a class="docs-footer-nextpage" href="../PencilIO/">Parallel I/O »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 24 June 2020 08:43">Wednesday 24 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>